'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.processCsvData = processCsvData;
exports.parseCsvDataByFieldType = parseCsvDataByFieldType;
exports.getFieldsFromData = getFieldsFromData;
exports.renameDuplicateFields = renameDuplicateFields;
exports.analyzerTypeToFieldType = analyzerTypeToFieldType;
exports.processRowObject = processRowObject;
exports.processGeojson = processGeojson;
exports.formatCsv = formatCsv;

var _d3Dsv = require('d3-dsv');

var _window = require('global/window');

var _typeAnalyzer = require('type-analyzer');

var _geojsonNormalize = require('geojson-normalize');

var _geojsonNormalize2 = _interopRequireDefault(_geojsonNormalize);

var _defaultSettings = require('../constants/default-settings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function processCsvData(rawData) {
  // here we assume the csv file that people uploaded will have first row
  // as name of the column
  var _csvParseRows = (0, _d3Dsv.csvParseRows)(rawData),
      headerRow = _csvParseRows[0],
      rows = _csvParseRows.slice(1);

  // NOTE: if rawData has duplicated column name, this will error out


  var rowObjs = (0, _d3Dsv.csvParse)(rawData);

  // analyzer will set any fields to 'string' if there are empty values
  // which will be parsed as '' by d3.csv
  // here we parse empty data as null

  rowObjs.forEach(function (row, rowIdx) {
    Object.keys(row).forEach(function (key, i) {
      // 'undefined' can happen if there
      // is no end-of-line marker, and cause problems down stream
      // TODO: figure out why d3 isn't handling this.
      if (row[key] === '' || row[key] === undefined) {
        row[key] = null;
        rows[rowIdx][i] = null;
      }
    });
  });

  if (!rowObjs.length || !headerRow) {
    // looks like an empty file
    // resolve null, and catch them later in one place
    return null;
  }

  var fields = getFieldsFromData(rowObjs, headerRow);
  fields.forEach(parseCsvDataByFieldType.bind(null, rows));

  return { fields: fields, rows: rows };
}

/**
 * Process uploaded csv file to parse value by field type
 *
 * @param {array} rows
 * @param {object} field
 * @param {number} i
 * @returns {void}
 */
function parseCsvDataByFieldType(rows, field, i) {
  var unixFormat = ['x', 'X'];

  switch (field.type) {
    case _defaultSettings.ALL_FIELD_TYPES.real:
      rows.forEach(function (row) {
        row[i] = parseFloat(row[i]);
      });
      break;

    // TODO: timestamp can be either '1495827326' or '2016-03-10 11:20'
    // if it's '1495827326' we pass it to int
    case _defaultSettings.ALL_FIELD_TYPES.timestamp:
      rows.forEach(function (row) {
        row[i] = row[i] !== null && row[i] !== '' && unixFormat.includes(field.format) ? Number(row[i]) : row[i];
      });

      break;

    case _defaultSettings.ALL_FIELD_TYPES.integer:
      rows.forEach(function (row) {
        row[i] = row[i] === null ? row[i] : parseInt(row[i], 10);
      });
      break;

    case _defaultSettings.ALL_FIELD_TYPES.boolean:
      rows.forEach(function (row) {
        row[i] = row[i] === null ? row[i] : row[i] === 'true' || row[i] === 'True';
      });
      break;

    default:
      break;
  }
}

/**
 * get fields from csv data
 *
 * @param {array} data
 * @param {array} fieldOrder
 * @returns {array} formatted fields
 */
function getFieldsFromData(data, fieldOrder) {
  // add a check for epoch timestamp
  var metadata = _typeAnalyzer.Analyzer.computeColMeta(data, [{ regex: /.*geojson|all_points/g, dataType: 'GEOMETRY' }]);

  var _renameDuplicateField = renameDuplicateFields(fieldOrder),
      fieldByIndex = _renameDuplicateField.fieldByIndex;

  return fieldOrder.reduce(function (orderedArray, field, index) {
    var name = fieldByIndex[index];
    var fieldMeta = metadata.find(function (m) {
      return m.key === field;
    });

    var _ref = fieldMeta || {},
        type = _ref.type,
        format = _ref.format;

    orderedArray[index] = {
      name: name,
      format: format,
      tableFieldIndex: index + 1,
      type: analyzerTypeToFieldType(type)
    };

    return orderedArray;
  }, []);
}

/**
 * pass in an array of field names, rename duplicated one
 * and return a map from old field index to new name
 *
 * @param {array} fieldOrder
 * @returns {Object} new field name by index
 */
function renameDuplicateFields(fieldOrder) {
  return fieldOrder.reduce(function (accu, field, i) {
    var allNames = accu.allNames;

    var fieldName = field;

    // add a counter to duplicated names
    if (allNames.includes(field)) {
      var counter = 0;
      while (allNames.includes(field + '-' + counter)) {
        counter++;
      }
      fieldName = field + '-' + counter;
    }

    accu.fieldByIndex[i] = fieldName;
    accu.allNames.push(fieldName);

    return accu;
  }, { allNames: [], fieldByIndex: {} });
}

/**
 * Map Analyzer types to local field types
 *
 * @param {string} aType
 * @returns {string} corresponding type in ALL_FIELD_TYPES
 */
/* eslint-disable complexity */
function analyzerTypeToFieldType(aType) {
  var DATE = _typeAnalyzer.DATA_TYPES.DATE,
      TIME = _typeAnalyzer.DATA_TYPES.TIME,
      DATETIME = _typeAnalyzer.DATA_TYPES.DATETIME,
      NUMBER = _typeAnalyzer.DATA_TYPES.NUMBER,
      INT = _typeAnalyzer.DATA_TYPES.INT,
      FLOAT = _typeAnalyzer.DATA_TYPES.FLOAT,
      BOOLEAN = _typeAnalyzer.DATA_TYPES.BOOLEAN,
      STRING = _typeAnalyzer.DATA_TYPES.STRING,
      CITY = _typeAnalyzer.DATA_TYPES.CITY,
      GEOMETRY = _typeAnalyzer.DATA_TYPES.GEOMETRY,
      GEOMETRY_FROM_STRING = _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING,
      ZIPCODE = _typeAnalyzer.DATA_TYPES.ZIPCODE,
      PAIR_GEOMETRY_FROM_STRING = _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING;

  // TODO: un recognized types
  // CURRENCY PERCENT NONE

  switch (aType) {
    case DATE:
      return _defaultSettings.ALL_FIELD_TYPES.date;
    case TIME:
    case DATETIME:
      return _defaultSettings.ALL_FIELD_TYPES.timestamp;
    case NUMBER:
    case FLOAT:
      return _defaultSettings.ALL_FIELD_TYPES.real;
    case INT:
      return _defaultSettings.ALL_FIELD_TYPES.integer;
    case BOOLEAN:
      return _defaultSettings.ALL_FIELD_TYPES.boolean;
    case GEOMETRY:
    case GEOMETRY_FROM_STRING:
    case PAIR_GEOMETRY_FROM_STRING:
      return _defaultSettings.ALL_FIELD_TYPES.geojson;
    case STRING:
    case CITY:
    case ZIPCODE:
      return _defaultSettings.ALL_FIELD_TYPES.string;
    default:
      _window.console.warn('Unsupported analyzer type: ' + aType);
      return _defaultSettings.ALL_FIELD_TYPES.string;
  }
}
/* eslint-enable complexity */

/*
 * Process rawData where each row is an object
 */
function processRowObject(rawData) {
  if (!rawData.length) {
    return null;
  }

  var keys = Object.keys(rawData[0]);
  var rows = rawData.map(function (d) {
    return keys.map(function (key) {
      return d[key];
    });
  });
  var fields = getFieldsFromData(rawData, keys);

  return {
    fields: fields,
    rows: rows
  };
}

function processGeojson(rawData) {
  var normalizedGeojson = (0, _geojsonNormalize2.default)(rawData);

  if (!normalizedGeojson || !Array.isArray(normalizedGeojson.features)) {
    // fail to normalize geojson
    return null;
  }

  // getting all feature fields
  var allData = normalizedGeojson.features.reduce(function (accu, f, i) {
    if (f.geometry) {
      accu.push((0, _extends3.default)({
        // add feature to _geojson field
        _geojson: f
      }, f.properties || {}));
    }
    return accu;
  }, []);

  // get all the field
  var fields = allData.reduce(function (prev, curr) {
    Object.keys(curr).forEach(function (key) {
      if (!prev.includes(key)) {
        prev.push(key);
      }
    });
    return prev;
  }, []);

  // make sure each feature has exact same fields
  allData.forEach(function (d) {
    fields.forEach(function (f) {
      if (!(f in d)) {
        d[f] = null;
      }
    });
  });

  return processRowObject(allData);
}

function formatCsv(data, fields) {
  var columns = fields.map(function (f) {
    return f.name;
  });
  return (0, _d3Dsv.csvFormatRows)([columns].concat(data));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9jZXNzb3IvZGF0YS1wcm9jZXNzb3IuanMiXSwibmFtZXMiOlsicHJvY2Vzc0NzdkRhdGEiLCJwYXJzZUNzdkRhdGFCeUZpZWxkVHlwZSIsImdldEZpZWxkc0Zyb21EYXRhIiwicmVuYW1lRHVwbGljYXRlRmllbGRzIiwiYW5hbHl6ZXJUeXBlVG9GaWVsZFR5cGUiLCJwcm9jZXNzUm93T2JqZWN0IiwicHJvY2Vzc0dlb2pzb24iLCJmb3JtYXRDc3YiLCJyYXdEYXRhIiwiaGVhZGVyUm93Iiwicm93cyIsInJvd09ianMiLCJmb3JFYWNoIiwicm93Iiwicm93SWR4IiwiT2JqZWN0Iiwia2V5cyIsImtleSIsImkiLCJ1bmRlZmluZWQiLCJsZW5ndGgiLCJmaWVsZHMiLCJiaW5kIiwiZmllbGQiLCJ1bml4Rm9ybWF0IiwidHlwZSIsInJlYWwiLCJwYXJzZUZsb2F0IiwidGltZXN0YW1wIiwiaW5jbHVkZXMiLCJmb3JtYXQiLCJOdW1iZXIiLCJpbnRlZ2VyIiwicGFyc2VJbnQiLCJib29sZWFuIiwiZGF0YSIsImZpZWxkT3JkZXIiLCJtZXRhZGF0YSIsImNvbXB1dGVDb2xNZXRhIiwicmVnZXgiLCJkYXRhVHlwZSIsImZpZWxkQnlJbmRleCIsInJlZHVjZSIsIm9yZGVyZWRBcnJheSIsImluZGV4IiwibmFtZSIsImZpZWxkTWV0YSIsImZpbmQiLCJtIiwidGFibGVGaWVsZEluZGV4IiwiYWNjdSIsImFsbE5hbWVzIiwiZmllbGROYW1lIiwiY291bnRlciIsInB1c2giLCJhVHlwZSIsIkRBVEUiLCJUSU1FIiwiREFURVRJTUUiLCJOVU1CRVIiLCJJTlQiLCJGTE9BVCIsIkJPT0xFQU4iLCJTVFJJTkciLCJDSVRZIiwiR0VPTUVUUlkiLCJHRU9NRVRSWV9GUk9NX1NUUklORyIsIlpJUENPREUiLCJQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HIiwiZGF0ZSIsImdlb2pzb24iLCJzdHJpbmciLCJ3YXJuIiwibWFwIiwiZCIsIm5vcm1hbGl6ZWRHZW9qc29uIiwiQXJyYXkiLCJpc0FycmF5IiwiZmVhdHVyZXMiLCJhbGxEYXRhIiwiZiIsImdlb21ldHJ5IiwiX2dlb2pzb24iLCJwcm9wZXJ0aWVzIiwicHJldiIsImN1cnIiLCJjb2x1bW5zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O1FBT2dCQSxjLEdBQUFBLGM7UUE2Q0FDLHVCLEdBQUFBLHVCO1FBK0NBQyxpQixHQUFBQSxpQjtRQStCQUMscUIsR0FBQUEscUI7UUErQkFDLHVCLEdBQUFBLHVCO1FBa0RBQyxnQixHQUFBQSxnQjtRQWVBQyxjLEdBQUFBLGM7UUEwQ0FDLFMsR0FBQUEsUzs7QUE1UWhCOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUE7Ozs7QUFFTyxTQUFTUCxjQUFULENBQXdCUSxPQUF4QixFQUFpQztBQUN0QztBQUNBO0FBRnNDLHNCQUlULHlCQUFhQSxPQUFiLENBSlM7QUFBQSxNQUkvQkMsU0FKK0I7QUFBQSxNQUlqQkMsSUFKaUI7O0FBTXRDOzs7QUFDQSxNQUFNQyxVQUFVLHFCQUFTSCxPQUFULENBQWhCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQUcsVUFBUUMsT0FBUixDQUFnQixVQUFDQyxHQUFELEVBQU1DLE1BQU4sRUFBaUI7QUFDL0JDLFdBQU9DLElBQVAsQ0FBWUgsR0FBWixFQUFpQkQsT0FBakIsQ0FBeUIsVUFBQ0ssR0FBRCxFQUFNQyxDQUFOLEVBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsVUFBSUwsSUFBSUksR0FBSixNQUFhLEVBQWIsSUFBbUJKLElBQUlJLEdBQUosTUFBYUUsU0FBcEMsRUFBK0M7QUFDN0NOLFlBQUlJLEdBQUosSUFBVyxJQUFYO0FBQ0FQLGFBQUtJLE1BQUwsRUFBYUksQ0FBYixJQUFrQixJQUFsQjtBQUNEO0FBQ0YsS0FSRDtBQVNELEdBVkQ7O0FBWUEsTUFBSSxDQUFDUCxRQUFRUyxNQUFULElBQW1CLENBQUNYLFNBQXhCLEVBQW1DO0FBQ2pDO0FBQ0E7QUFDQSxXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFNWSxTQUFTbkIsa0JBQWtCUyxP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QVA7QUFDRDs7QUFFTSxTQUFTeEUsU0FBVCxDQUFtQjRCLElBQW5CLEVBQXlCZCxNQUF6QixFQUFpQztBQUN0QyxNQUFNaUUsVUFBVWpFLE9BQU9vRCxHQUFQLENBQVc7QUFBQSxXQUFLTyxFQUFFbkMsSUFBUDtBQUFBLEdBQVgsQ0FBaEI7QUFDQSxTQUFPLDJCQUFleUMsT0FBZixTQUEyQm5ELElBQTNCLEVBQVA7QUFDRCIsImZpbGUiOiJkYXRhLXByb2Nlc3Nvci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3N2UGFyc2UsIGNzdlBhcnNlUm93cywgY3N2Rm9ybWF0Um93c30gZnJvbSAnZDMtZHN2JztcbmltcG9ydCB7Y29uc29sZSBhcyBnbG9iYWxDb25zb2xlfSBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCB7QW5hbHl6ZXIsIERBVEFfVFlQRVMgYXMgQW5hbHl6ZXJEQVRBX1RZUEVTfSBmcm9tICd0eXBlLWFuYWx5emVyJztcbmltcG9ydCBub3JtYWxpemUgZnJvbSAnZ2VvanNvbi1ub3JtYWxpemUnO1xuXG5pbXBvcnQge0FMTF9GSUVMRF9UWVBFU30gZnJvbSAnLi4vY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0NzdkRhdGEocmF3RGF0YSkge1xuICAvLyBoZXJlIHdlIGFzc3VtZSB0aGUgY3N2IGZpbGUgdGhhdCBwZW9wbGUgdXBsb2FkZWQgd2lsbCBoYXZlIGZpcnN0IHJvd1xuICAvLyBhcyBuYW1lIG9mIHRoZSBjb2x1bW5cbiAgLy9UT0RPOiBhZGQgYSBhbGVydCBhdCB1cGxvYWQgY3N2IHRvIHJlbWluZCBkZWZpbmUgZmlyc3Qgcm93XG4gIGNvbnN0IFtoZWFkZXJSb3csIC4uLnJvd3NdID0gY3N2UGFyc2VSb3dzKHJhd0RhdGEpO1xuXG4gIC8vIE5PVEU6IGlmIHJhd0RhdGEgaGFzIGR1cGxpY2F0ZWQgY29sdW1uIG5hbWUsIHRoaXMgd2lsbCBlcnJvciBvdXRcbiAgY29uc3Qgcm93T2JqcyA9IGNzdlBhcnNlKHJhd0RhdGEpO1xuXG4gIC8vIGFuYWx5emVyIHdpbGwgc2V0IGFueSBmaWVsZHMgdG8gJ3N0cmluZycgaWYgdGhlcmUgYXJlIGVtcHR5IHZhbHVlc1xuICAvLyB3aGljaCB3aWxsIGJlIHBhcnNlZCBhcyAnJyBieSBkMy5jc3ZcbiAgLy8gaGVyZSB3ZSBwYXJzZSBlbXB0eSBkYXRhIGFzIG51bGxcblxuICByb3dPYmpzLmZvckVhY2goKHJvdywgcm93SWR4KSA9PiB7XG4gICAgT2JqZWN0LmtleXMocm93KS5mb3JFYWNoKChrZXksIGkpID0+IHtcbiAgICAgIC8vICd1bmRlZmluZWQnIGNhbiBoYXBwZW4gaWYgdGhlcmVcbiAgICAgIC8vIGlzIG5vIGVuZC1vZi1saW5lIG1hcmtlciwgYW5kIGNhdXNlIHByb2JsZW1zIGRvd24gc3RyZWFtXG4gICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IHdoeSBkMyBpc24ndCBoYW5kbGluZyB0aGlzLlxuICAgICAgaWYgKHJvd1trZXldID09PSAnJyB8fCByb3dba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvd1trZXldID0gbnVsbDtcbiAgICAgICAgcm93c1tyb3dJZHhdW2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKCFyb3dPYmpzLmxlbmd0aCB8fCAhaGVhZGVyUm93KSB7XG4gICAgLy8gbG9va3MgbGlrZSBhbiBlbXB0eSBmaWxlXG4gICAgLy8gcmVzb2x2ZSBudWxsLCBhbmQgY2F0Y2ggdGhlbSBsYXRlciBpbiBvbmUgcGxhY2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZpZWxkcyA9IGdldEZpZWxkc0Zyb21EYXRhKHJvd09ianMsIGhlYWRlclJvdyk7XG4gIGZpZWxkcy5mb3JFYWNoKHBhcnNlQ3N2RGF0YUJ5RmllbGRUeXBlLmJpbmQobnVsbCwgcm93cykpO1xuXG4gIHJldHVybiB7ZmllbGRzLCByb3dzfTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHVwbG9hZGVkIGNzdiBmaWxlIHRvIHBhcnNlIHZhbHVlIGJ5IGZpZWxkIHR5cGVcbiAqXG4gKiBAcGFyYW0ge2FycmF5fSByb3dzXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3N2RGF0YUJ5RmllbGRUeXBlKHJvd3MsIGZpZWxkLCBpKSB7XG4gIGNvbnN0IHVuaXhGb3JtYXQgPSBbJ3gnLCAnWCddO1xuXG4gIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnJlYWw6XG4gICAgICByb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgcm93W2ldID0gcGFyc2VGbG9hdChyb3dbaV0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIC8vIFRPRE86IHRpbWVzdGFtcCBjYW4gYmUgZWl0aGVyICcxNDk1ODI3MzI2JyBvciAnMjAxNi0wMy0xMCAxMToyMCdcbiAgICAvLyBpZiBpdCdzICcxNDk1ODI3MzI2JyB3ZSBwYXNzIGl0IHRvIGludFxuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnRpbWVzdGFtcDpcbiAgICAgIHJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICByb3dbaV0gPVxuICAgICAgICAgIHJvd1tpXSAhPT0gbnVsbCAmJiByb3dbaV0gIT09ICcnICYmIHVuaXhGb3JtYXQuaW5jbHVkZXMoZmllbGQuZm9ybWF0KVxuICAgICAgICAgICAgPyBOdW1iZXIocm93W2ldKVxuICAgICAgICAgICAgOiByb3dbaV07XG4gICAgICB9KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyOlxuICAgICAgcm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIHJvd1tpXSA9IHJvd1tpXSA9PT0gbnVsbCA/IHJvd1tpXSA6IHBhcnNlSW50KHJvd1tpXSwgMTApO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLmJvb2xlYW46XG4gICAgICByb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgcm93W2ldID1cbiAgICAgICAgICByb3dbaV0gPT09IG51bGwgPyByb3dbaV0gOiByb3dbaV0gPT09ICd0cnVlJyB8fCByb3dbaV0gPT09ICdUcnVlJztcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLyoqXG4gKiBnZXQgZmllbGRzIGZyb20gY3N2IGRhdGFcbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBkYXRhXG4gKiBAcGFyYW0ge2FycmF5fSBmaWVsZE9yZGVyXG4gKiBAcmV0dXJucyB7YXJyYXl9IGZvcm1hdHRlZCBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkc0Zyb21EYXRhKGRhdGEsIGZpZWxkT3JkZXIpIHtcbiAgLy8gYWRkIGEgY2hlY2sgZm9yIGVwb2NoIHRpbWVzdGFtcFxuICBjb25zdCBtZXRhZGF0YSA9IEFuYWx5emVyLmNvbXB1dGVDb2xNZXRhKGRhdGEsIFtcbiAgICB7cmVnZXg6IC8uKmdlb2pzb258YWxsX3BvaW50cy9nLCBkYXRhVHlwZTogJ0dFT01FVFJZJ31cbiAgXSk7XG5cbiAgY29uc3Qge2ZpZWxkQnlJbmRleH0gPSByZW5hbWVEdXBsaWNhdGVGaWVsZHMoZmllbGRPcmRlcik7XG5cbiAgcmV0dXJuIGZpZWxkT3JkZXIucmVkdWNlKChvcmRlcmVkQXJyYXksIGZpZWxkLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBmaWVsZEJ5SW5kZXhbaW5kZXhdO1xuICAgIGNvbnN0IGZpZWxkTWV0YSA9IG1ldGFkYXRhLmZpbmQobSA9PiBtLmtleSA9PT0gZmllbGQpO1xuICAgIGNvbnN0IHt0eXBlLCBmb3JtYXR9ID0gZmllbGRNZXRhIHx8IHt9O1xuXG4gICAgb3JkZXJlZEFycmF5W2luZGV4XSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICBmb3JtYXQsXG4gICAgICB0YWJsZUZpZWxkSW5kZXg6IGluZGV4ICsgMSxcbiAgICAgIHR5cGU6IGFuYWx5emVyVHlwZVRvRmllbGRUeXBlKHR5cGUpXG4gICAgfTtcblxuICAgIHJldHVybiBvcmRlcmVkQXJyYXk7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBwYXNzIGluIGFuIGFycmF5IG9mIGZpZWxkIG5hbWVzLCByZW5hbWUgZHVwbGljYXRlZCBvbmVcbiAqIGFuZCByZXR1cm4gYSBtYXAgZnJvbSBvbGQgZmllbGQgaW5kZXggdG8gbmV3IG5hbWVcbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBmaWVsZE9yZGVyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXcgZmllbGQgbmFtZSBieSBpbmRleFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuYW1lRHVwbGljYXRlRmllbGRzKGZpZWxkT3JkZXIpIHtcbiAgcmV0dXJuIGZpZWxkT3JkZXIucmVkdWNlKFxuICAgIChhY2N1LCBmaWVsZCwgaSkgPT4ge1xuICAgICAgY29uc3Qge2FsbE5hbWVzfSA9IGFjY3U7XG4gICAgICBsZXQgZmllbGROYW1lID0gZmllbGQ7XG5cbiAgICAgIC8vIGFkZCBhIGNvdW50ZXIgdG8gZHVwbGljYXRlZCBuYW1lc1xuICAgICAgaWYgKGFsbE5hbWVzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIHdoaWxlIChhbGxOYW1lcy5pbmNsdWRlcyhgJHtmaWVsZH0tJHtjb3VudGVyfWApKSB7XG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkTmFtZSA9IGAke2ZpZWxkfS0ke2NvdW50ZXJ9YDtcbiAgICAgIH1cblxuICAgICAgYWNjdS5maWVsZEJ5SW5kZXhbaV0gPSBmaWVsZE5hbWU7XG4gICAgICBhY2N1LmFsbE5hbWVzLnB1c2goZmllbGROYW1lKTtcblxuICAgICAgcmV0dXJuIGFjY3U7XG4gICAgfSxcbiAgICB7YWxsTmFtZXM6IFtdLCBmaWVsZEJ5SW5kZXg6IHt9fVxuICApO1xufVxuXG4vKipcbiAqIE1hcCBBbmFseXplciB0eXBlcyB0byBsb2NhbCBmaWVsZCB0eXBlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhVHlwZVxuICogQHJldHVybnMge3N0cmluZ30gY29ycmVzcG9uZGluZyB0eXBlIGluIEFMTF9GSUVMRF9UWVBFU1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gYW5hbHl6ZXJUeXBlVG9GaWVsZFR5cGUoYVR5cGUpIHtcbiAgY29uc3Qge1xuICAgIERBVEUsXG4gICAgVElNRSxcbiAgICBEQVRFVElNRSxcbiAgICBOVU1CRVIsXG4gICAgSU5ULFxuICAgIEZMT0FULFxuICAgIEJPT0xFQU4sXG4gICAgU1RSSU5HLFxuICAgIENJVFksXG4gICAgR0VPTUVUUlksXG4gICAgR0VPTUVUUllfRlJPTV9TVFJJTkcsXG4gICAgWklQQ09ERSxcbiAgICBQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HXG4gIH0gPSBBbmFseXplckRBVEFfVFlQRVM7XG5cbiAgLy8gVE9ETzogdW4gcmVjb2duaXplZCB0eXBlc1xuICAvLyBDVVJSRU5DWSBQRVJDRU5UIE5PTkVcbiAgc3dpdGNoIChhVHlwZSkge1xuICAgIGNhc2UgREFURTpcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMuZGF0ZTtcbiAgICBjYXNlIFRJTUU6XG4gICAgY2FzZSBEQVRFVElNRTpcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMudGltZXN0YW1wO1xuICAgIGNhc2UgTlVNQkVSOlxuICAgIGNhc2UgRkxPQVQ6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLnJlYWw7XG4gICAgY2FzZSBJTlQ6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLmludGVnZXI7XG4gICAgY2FzZSBCT09MRUFOOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5ib29sZWFuO1xuICAgIGNhc2UgR0VPTUVUUlk6XG4gICAgY2FzZSBHRU9NRVRSWV9GUk9NX1NUUklORzpcbiAgICBjYXNlIFBBSVJfR0VPTUVUUllfRlJPTV9TVFJJTkc6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLmdlb2pzb247XG4gICAgY2FzZSBTVFJJTkc6XG4gICAgY2FzZSBDSVRZOlxuICAgIGNhc2UgWklQQ09ERTpcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMuc3RyaW5nO1xuICAgIGRlZmF1bHQ6XG4gICAgICBnbG9iYWxDb25zb2xlLndhcm4oYFVuc3VwcG9ydGVkIGFuYWx5emVyIHR5cGU6ICR7YVR5cGV9YCk7XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLnN0cmluZztcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbi8qXG4gKiBQcm9jZXNzIHJhd0RhdGEgd2hlcmUgZWFjaCByb3cgaXMgYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzUm93T2JqZWN0KHJhd0RhdGEpIHtcbiAgaWYgKCFyYXdEYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJhd0RhdGFbMF0pO1xuICBjb25zdCByb3dzID0gcmF3RGF0YS5tYXAoZCA9PiBrZXlzLm1hcChrZXkgPT4gZFtrZXldKSk7XG4gIGNvbnN0IGZpZWxkcyA9IGdldEZpZWxkc0Zyb21EYXRhKHJhd0RhdGEsIGtleXMpO1xuXG4gIHJldHVybiB7XG4gICAgZmllbGRzLFxuICAgIHJvd3NcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NHZW9qc29uKHJhd0RhdGEpIHtcbiAgY29uc3Qgbm9ybWFsaXplZEdlb2pzb24gPSBub3JtYWxpemUocmF3RGF0YSk7XG5cbiAgaWYgKCFub3JtYWxpemVkR2VvanNvbiB8fCAhQXJyYXkuaXNBcnJheShub3JtYWxpemVkR2VvanNvbi5mZWF0dXJlcykpIHtcbiAgICAvLyBmYWlsIHRvIG5vcm1hbGl6ZSBnZW9qc29uXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBnZXR0aW5nIGFsbCBmZWF0dXJlIGZpZWxkc1xuICBjb25zdCBhbGxEYXRhID0gbm9ybWFsaXplZEdlb2pzb24uZmVhdHVyZXMucmVkdWNlKChhY2N1LCBmLCBpKSA9PiB7XG4gICAgaWYgKGYuZ2VvbWV0cnkpIHtcbiAgICAgIGFjY3UucHVzaCh7XG4gICAgICAgIC8vIGFkZCBmZWF0dXJlIHRvIF9nZW9qc29uIGZpZWxkXG4gICAgICAgIF9nZW9qc29uOiBmLFxuICAgICAgICAuLi4oZi5wcm9wZXJ0aWVzIHx8IHt9KVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1O1xuICB9LCBbXSk7XG5cbiAgLy8gZ2V0IGFsbCB0aGUgZmllbGRcbiAgY29uc3QgZmllbGRzID0gYWxsRGF0YS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICBPYmplY3Qua2V5cyhjdXJyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIXByZXYuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBwcmV2LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJldjtcbiAgfSwgW10pO1xuXG4gIC8vIG1ha2Ugc3VyZSBlYWNoIGZlYXR1cmUgaGFzIGV4YWN0IHNhbWUgZmllbGRzXG4gIGFsbERhdGEuZm9yRWFjaChkID0+IHtcbiAgICBmaWVsZHMuZm9yRWFjaChmID0+IHtcbiAgICAgIGlmICghKGYgaW4gZCkpIHtcbiAgICAgICAgZFtmXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9jZXNzUm93T2JqZWN0KGFsbERhdGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Q3N2KGRhdGEsIGZpZWxkcykge1xuICBjb25zdCBjb2x1bW5zID0gZmllbGRzLm1hcChmID0+IGYubmFtZSk7XG4gIHJldHVybiBjc3ZGb3JtYXRSb3dzKFtjb2x1bW5zLCAuLi5kYXRhXSk7XG59XG4iXX0=
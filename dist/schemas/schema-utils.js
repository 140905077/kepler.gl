'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.savePropertiesOrApplySchema = savePropertiesOrApplySchema;
exports.loadPropertiesOrApplySchema = loadPropertiesOrApplySchema;
exports.getPropertyValueFromSchema = getPropertyValueFromSchema;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Recursively save / load value for state based on property keys,
 * if property[key] is another schema
 * Use is to get value to save
 * @param {Object} opertation - 'save' or 'load'
 * @param {Object} state - state to save
 * @param {Object} properties - properties schema
 * @returns {Object} - saved state
 */
function savePropertiesOrApplySchema(state, properties) {
  return getPropertyValueFromSchema('save', state, properties);
}

function loadPropertiesOrApplySchema(state, properties) {
  return getPropertyValueFromSchema('load', state, properties);
}

function getPropertyValueFromSchema(operation, state, properties) {
  return Object.keys(properties).reduce(function (accu, key) {
    return (0, _extends3.default)({}, accu, key in state ? properties[key] ? // if it's another schema
    properties[key][operation] ? // call save or load
    properties[key][operation](state[key], state) : // if it's another property object
    getPropertyValueFromSchema(operation, state[key], properties[key]) : (0, _defineProperty3.default)({}, key, state[key]) : {});
  }, {});
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWFzL3NjaGVtYS11dGlscy5qcyJdLCJuYW1lcyI6WyJzYXZlUHJvcGVydGllc09yQXBwbHlTY2hlbWEiLCJsb2FkUHJvcGVydGllc09yQXBwbHlTY2hlbWEiLCJnZXRQcm9wZXJ0eVZhbHVlRnJvbVNjaGVtYSIsInN0YXRlIiwicHJvcGVydGllcyIsIm9wZXJhdGlvbiIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2N1Iiwia2V5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztRQVNnQkEsMkIsR0FBQUEsMkI7UUFJQUMsMkIsR0FBQUEsMkI7UUFJQUMsMEIsR0FBQUEsMEI7Ozs7QUFqQmhCOzs7Ozs7Ozs7QUFTTyxTQUFTRiwyQkFBVCxDQUFxQ0csS0FBckMsRUFBNENDLFVBQTVDLEVBQXdEO0FBQzdELFNBQU9GLDJCQUEyQixNQUEzQixFQUFtQ0MsS0FBbkMsRUFBMENDLFVBQTFDLENBQVA7QUFDRDs7QUFFTSxTQUFTSCwyQkFBVCxDQUFxQ0UsS0FBckMsRUFBNENDLFVBQTVDLEVBQXdEO0FBQzdELFNBQU9GLDJCQUEyQixNQUEzQixFQUFtQ0MsS0FBbkMsRUFBMENDLFVBQTFDLENBQVA7QUFDRDs7QUFFTSxTQUFTRiwwQkFBVCxDQUFvQ0csU0FBcEMsRUFBK0NGLEtBQS9DLEVBQXNEQyxVQUF0RCxFQUFrRTtBQUN2RSxTQUFPRSxPQUFPQyxJQUFQLENBQVlILFVBQVosRUFBd0JJLE1BQXhCLENBQ0wsVUFBQ0MsSUFBRCxFQUFPQyxHQUFQO0FBQUEsc0NBQ0tELElBREwsRUFFTUMsT0FBT1AsS0FBUCxHQUNBQyxXQUFXTSxHQUFYLElBQ0U7QUFDQU4sZUFBV00sR0FBWCxFQUFnQkwsU0FBaEIsSUFDRTtBQUNBRCxlQUFXTSxHQUFYLEVBQWdCTCxTQUFoQixFQUEyQkYsTUFBTU8sR0FBTixDQUEzQixFQUF1Q1AsS0FBdkMsQ0FGRixHQUdFO0FBQ0FELCtCQUEyQkcsU0FBM0IsRUFBc0NGLE1BQU1PLEdBQU4sQ0FBdEMsRUFBa0ROLFdBQVdNLEdBQVgsQ0FBbEQsQ0FOSixxQ0FPSUEsR0FQSixFQU9VUCxNQUFNTyxHQUFOLENBUFYsQ0FEQSxHQVNBLEVBWE47QUFBQSxHQURLLEVBY0wsRUFkSyxDQUFQO0FBZ0JEIiwiZmlsZSI6InNjaGVtYS11dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVjdXJzaXZlbHkgc2F2ZSAvIGxvYWQgdmFsdWUgZm9yIHN0YXRlIGJhc2VkIG9uIHByb3BlcnR5IGtleXMsXG4gKiBpZiBwcm9wZXJ0eVtrZXldIGlzIGFub3RoZXIgc2NoZW1hXG4gKiBVc2UgaXMgdG8gZ2V0IHZhbHVlIHRvIHNhdmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVydGF0aW9uIC0gJ3NhdmUnIG9yICdsb2FkJ1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIC0gc3RhdGUgdG8gc2F2ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBwcm9wZXJ0aWVzIHNjaGVtYVxuICogQHJldHVybnMge09iamVjdH0gLSBzYXZlZCBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVByb3BlcnRpZXNPckFwcGx5U2NoZW1hKHN0YXRlLCBwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBnZXRQcm9wZXJ0eVZhbHVlRnJvbVNjaGVtYSgnc2F2ZScsIHN0YXRlLCBwcm9wZXJ0aWVzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRQcm9wZXJ0aWVzT3JBcHBseVNjaGVtYShzdGF0ZSwgcHJvcGVydGllcykge1xuICByZXR1cm4gZ2V0UHJvcGVydHlWYWx1ZUZyb21TY2hlbWEoJ2xvYWQnLCBzdGF0ZSwgcHJvcGVydGllcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wZXJ0eVZhbHVlRnJvbVNjaGVtYShvcGVyYXRpb24sIHN0YXRlLCBwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICAuLi4oa2V5IGluIHN0YXRlXG4gICAgICAgID8gcHJvcGVydGllc1trZXldXG4gICAgICAgICAgPyAvLyBpZiBpdCdzIGFub3RoZXIgc2NoZW1hXG4gICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV1bb3BlcmF0aW9uXVxuICAgICAgICAgICAgPyAvLyBjYWxsIHNhdmUgb3IgbG9hZFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV1bb3BlcmF0aW9uXShzdGF0ZVtrZXldLCBzdGF0ZSlcbiAgICAgICAgICAgIDogLy8gaWYgaXQncyBhbm90aGVyIHByb3BlcnR5IG9iamVjdFxuICAgICAgICAgICAgICBnZXRQcm9wZXJ0eVZhbHVlRnJvbVNjaGVtYShvcGVyYXRpb24sIHN0YXRlW2tleV0sIHByb3BlcnRpZXNba2V5XSlcbiAgICAgICAgICA6IHtba2V5XTogc3RhdGVba2V5XX1cbiAgICAgICAgOiB7fSlcbiAgICB9KSxcbiAgICB7fVxuICApO1xufVxuIl19
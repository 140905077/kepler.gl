"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* vertex shader for the choropleth-layer */
exports.default = "\n#define SHADER_NAME choropleth-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\n\n// projection uniforms\nuniform float mercatorScale;\nuniform mat4 worldMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 worldInverseTransposeMatrix;\n\n// Custom uniforms\nuniform float pixelPerMeter;\nuniform float opacity;\nuniform vec3 colors;\n\n// Lighting constants, this can also be set via uniform\nconst vec3 ambientColor = vec3(1., 1., 1.);\nconst vec3 pointLocation = vec3(-1., 3., -1.);\nconst vec3 pointColor = vec3(1., 1., 1.);\nconst vec3 pointSpecularColor = vec3(0.6, 0.6, 0.6);\nconst float shininess = 3.;\nconst float pointLightAmbientCoefficient = 0.8;\n\nvarying vec4 vColor;\n\nvec3 getLightWeight(\n  mat4 viewMatrix,\n  mat4 worldMatrix,\n  mat4 worldInverseTransposeMatrix,\n  vec3 positions,\n  vec3 normals,\n  vec3 ambientColor,\n  vec3 pointLocation,\n  vec3 pointColor,\n  vec3 pointSpecularColor,\n  float shininess,\n  float pointLightAmbientCoefficient\n) {\n  vec4 vPosition = worldMatrix * vec4(positions, 1.0);\n  vec4 vTransformedNormal = worldInverseTransposeMatrix * vec4(normals, 1);\n  vec3 normal = vTransformedNormal.xyz;\n  vec3 eyeDirection = normalize(-vPosition.xyz);\n\n  vec3 transformedPointLocation = (viewMatrix * vec4(pointLocation, 1.0)).xyz;\n  vec3 lightDirection = normalize(transformedPointLocation - vPosition.xyz);\n  vec3 reflectionDirection = reflect(-lightDirection, normal);\n\n  float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), clamp(shininess, 1., 32.));\n  vec3 specularLight = specularLightWeighting * pointSpecularColor;\n\n  float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);\n  vec3 diffuseLight = diffuseLightWeighting * pointColor;\n\n\n  return (ambientColor * pointLightAmbientCoefficient) + diffuseLight + specularLight;\n}\n\nvoid main(void) {\n  // For some reason, need to add one to elevation to show up in untilted mode\n  vec3 p = vec3(\n    project_position(positions.xy),\n    positions.z * pixelPerMeter + .1\n  );\n\n  gl_Position = project_to_clipspace(vec4(p, 1.));\n\n  vec3 lightWeighting = getLightWeight(\n    viewMatrix,\n    worldMatrix,\n    worldInverseTransposeMatrix,\n    p,\n    normals,\n    ambientColor,\n    pointLocation,\n    pointColor,\n    pointSpecularColor,\n    shininess,\n    pointLightAmbientCoefficient\n  );\n\n  vec3 lightWeightedColor = lightWeighting * colors / 255.0;\n\n  // vec3 color = applyLighting(gl_Position.xyz, normals, colors);\n  vColor = vec4(color, opacity);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZWNrZ2wtbGF5ZXJzL2J1aWxkaW5nLWxheWVyL2J1aWxkaW5nLWxheWVyLXZlcnRleC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiYnVpbGRpbmctbGF5ZXItdmVydGV4Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiB2ZXJ0ZXggc2hhZGVyIGZvciB0aGUgY2hvcm9wbGV0aC1sYXllciAqL1xuZXhwb3J0IGRlZmF1bHQgYFxcXG5cbiNkZWZpbmUgU0hBREVSX05BTUUgY2hvcm9wbGV0aC1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XG5cbi8vIHByb2plY3Rpb24gdW5pZm9ybXNcbnVuaWZvcm0gZmxvYXQgbWVyY2F0b3JTY2FsZTtcbnVuaWZvcm0gbWF0NCB3b3JsZE1hdHJpeDtcbnVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xudW5pZm9ybSBtYXQ0IHdvcmxkSW52ZXJzZVRyYW5zcG9zZU1hdHJpeDtcblxuLy8gQ3VzdG9tIHVuaWZvcm1zXG51bmlmb3JtIGZsb2F0IHBpeGVsUGVyTWV0ZXI7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIHZlYzMgY29sb3JzO1xuXG4vLyBMaWdodGluZyBjb25zdGFudHMsIHRoaXMgY2FuIGFsc28gYmUgc2V0IHZpYSB1bmlmb3JtXG5jb25zdCB2ZWMzIGFtYmllbnRDb2xvciA9IHZlYzMoMS4sIDEuLCAxLik7XG5jb25zdCB2ZWMzIHBvaW50TG9jYXRpb24gPSB2ZWMzKC0xLiwgMy4sIC0xLik7XG5jb25zdCB2ZWMzIHBvaW50Q29sb3IgPSB2ZWMzKDEuLCAxLiwgMS4pO1xuY29uc3QgdmVjMyBwb2ludFNwZWN1bGFyQ29sb3IgPSB2ZWMzKDAuNiwgMC42LCAwLjYpO1xuY29uc3QgZmxvYXQgc2hpbmluZXNzID0gMy47XG5jb25zdCBmbG9hdCBwb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50ID0gMC44O1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG52ZWMzIGdldExpZ2h0V2VpZ2h0KFxuICBtYXQ0IHZpZXdNYXRyaXgsXG4gIG1hdDQgd29ybGRNYXRyaXgsXG4gIG1hdDQgd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4LFxuICB2ZWMzIHBvc2l0aW9ucyxcbiAgdmVjMyBub3JtYWxzLFxuICB2ZWMzIGFtYmllbnRDb2xvcixcbiAgdmVjMyBwb2ludExvY2F0aW9uLFxuICB2ZWMzIHBvaW50Q29sb3IsXG4gIHZlYzMgcG9pbnRTcGVjdWxhckNvbG9yLFxuICBmbG9hdCBzaGluaW5lc3MsXG4gIGZsb2F0IHBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnRcbikge1xuICB2ZWM0IHZQb3NpdGlvbiA9IHdvcmxkTWF0cml4ICogdmVjNChwb3NpdGlvbnMsIDEuMCk7XG4gIHZlYzQgdlRyYW5zZm9ybWVkTm9ybWFsID0gd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4ICogdmVjNChub3JtYWxzLCAxKTtcbiAgdmVjMyBub3JtYWwgPSB2VHJhbnNmb3JtZWROb3JtYWwueHl6O1xuICB2ZWMzIGV5ZURpcmVjdGlvbiA9IG5vcm1hbGl6ZSgtdlBvc2l0aW9uLnh5eik7XG5cbiAgdmVjMyB0cmFuc2Zvcm1lZFBvaW50TG9jYXRpb24gPSAodmlld01hdHJpeCAqIHZlYzQocG9pbnRMb2NhdGlvbiwgMS4wKSkueHl6O1xuICB2ZWMzIGxpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKHRyYW5zZm9ybWVkUG9pbnRMb2NhdGlvbiAtIHZQb3NpdGlvbi54eXopO1xuICB2ZWMzIHJlZmxlY3Rpb25EaXJlY3Rpb24gPSByZWZsZWN0KC1saWdodERpcmVjdGlvbiwgbm9ybWFsKTtcblxuICBmbG9hdCBzcGVjdWxhckxpZ2h0V2VpZ2h0aW5nID0gcG93KG1heChkb3QocmVmbGVjdGlvbkRpcmVjdGlvbiwgZXllRGlyZWN0aW9uKSwgMC4wKSwgY2xhbXAoc2hpbmluZXNzLCAxLiwgMzIuKSk7XG4gIHZlYzMgc3BlY3VsYXJMaWdodCA9IHNwZWN1bGFyTGlnaHRXZWlnaHRpbmcgKiBwb2ludFNwZWN1bGFyQ29sb3I7XG5cbiAgZmxvYXQgZGlmZnVzZUxpZ2h0V2VpZ2h0aW5nID0gbWF4KGRvdChub3JtYWwsIGxpZ2h0RGlyZWN0aW9uKSwgMC4wKTtcbiAgdmVjMyBkaWZmdXNlTGlnaHQgPSBkaWZmdXNlTGlnaHRXZWlnaHRpbmcgKiBwb2ludENvbG9yO1xuXG5cbiAgcmV0dXJuIChhbWJpZW50Q29sb3IgKiBwb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50KSArIGRpZmZ1c2VMaWdodCArIHNwZWN1bGFyTGlnaHQ7XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIC8vIEZvciBzb21lIHJlYXNvbiwgbmVlZCB0byBhZGQgb25lIHRvIGVsZXZhdGlvbiB0byBzaG93IHVwIGluIHVudGlsdGVkIG1vZGVcbiAgdmVjMyBwID0gdmVjMyhcbiAgICBwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9ucy54eSksXG4gICAgcG9zaXRpb25zLnogKiBwaXhlbFBlck1ldGVyICsgLjFcbiAgKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQocCwgMS4pKTtcblxuICB2ZWMzIGxpZ2h0V2VpZ2h0aW5nID0gZ2V0TGlnaHRXZWlnaHQoXG4gICAgdmlld01hdHJpeCxcbiAgICB3b3JsZE1hdHJpeCxcbiAgICB3b3JsZEludmVyc2VUcmFuc3Bvc2VNYXRyaXgsXG4gICAgcCxcbiAgICBub3JtYWxzLFxuICAgIGFtYmllbnRDb2xvcixcbiAgICBwb2ludExvY2F0aW9uLFxuICAgIHBvaW50Q29sb3IsXG4gICAgcG9pbnRTcGVjdWxhckNvbG9yLFxuICAgIHNoaW5pbmVzcyxcbiAgICBwb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50XG4gICk7XG5cbiAgdmVjMyBsaWdodFdlaWdodGVkQ29sb3IgPSBsaWdodFdlaWdodGluZyAqIGNvbG9ycyAvIDI1NS4wO1xuXG4gIC8vIHZlYzMgY29sb3IgPSBhcHBseUxpZ2h0aW5nKGdsX1Bvc2l0aW9uLnh5eiwgbm9ybWFscywgY29sb3JzKTtcbiAgdkNvbG9yID0gdmVjNChjb2xvciwgb3BhY2l0eSk7XG59XG5gO1xuIl19